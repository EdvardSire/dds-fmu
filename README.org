* DDS FMU Mediator

  + Create a mediator between cosim/FMU and DDS
  + There are several avenues for accomplishing interoperability between FMU and DDS
   | No. | Option                     | Has been attempted   | Flexibility | Downsides                         |
   |-----+----------------------------+----------------------+-------------+-----------------------------------|
   |   1 | Cosim observer/manipulator | Yes in FKIN project  | Medium      | Changes to libcosim, compilations |
   |   2 | With cosim slave interface | Yes in SFI MOVE      | Medium      | Changes to libcosim, compilations |
   |   3 | As an FMU                  | Some, using Ratatosk | High        | Implementation effort             |

  + Option 3 is most sought, since it can be used by any FMU co-simulator and does not
    require source code changes to libcosim
  + Feature requirements
    + Given an idl-file, ability to dynamically create publishers/subscribers of these at runtime
    + Could be sufficient to run an idl parser for the dds types plus appropriate config
    + Configuration file with a mapping from DDS topics and fields to FMU inputs/outputs.
    + Should be able to create appropriate publishers/subscribers according to config file
    + Auto-generate modelDescription.xml (and ospDescription.xml? No) from config file(s)
    + Could use yaml as auxiliary configuration file
    + Should resources/ bundle necessary stuff for reconfiguration, or should there be a compilable project?
      + The FMU should be able to repackage itself
  + Suggested approaches for Option 3
    + C/C++
      + [X] Fundamendals :: CMake, conan, viproma/cppfmu to create an FMU
      + [X] DDS mediation :: Hand-code an FMU with simple DDS publish/subscribe
      + Configurability :: Tools for generating  modelDescription.xml and FMU necessities
        + Signal mapping DDS topic/type to/from FMU input/output defined in a yaml
          file. Note that fast-dds profiles probably serves this purpose.
        + Static linking of runtime dependencies if possible (idlc static lib?, static libddsc?) (cyclone-dds, fast-dds)
          + we are going for fast-dds
      + Extensible :: Deal with new IDL-files and new signal mappings. Repackaging of FMU needed. Without recompilation.
      + Complications :: Recompilation is needed unless parsing can be done runtime
      + Consistency :: UUID of IDL file, config file and modelDescription to ensure unique FMU
      + Checking :: Signal connections should be checked for existence (members exists and such)
      + YAML :: Use yaml instead of xml for human input, use and bundle yq tool if needed (!)
    + Python
      + Use a python fmu library, unifmu, pyfmu, pythonfmu
      + Use Cyclonedds-python for DDS side
      + Perhaps PyOxidizer for packaging
      + May be easier to handle dynamic types at runtime
      + How to parse IDL?
      + There are several inconveniences too, especially related to packaging
        + python runtime and transitive dependencies, bundled appropriately

** Implementation tasks

   + [X] Load idl files
   + [4/5] Load xml profiles as common for Fast-DDS (how many participants?)
     + [X] Load participant profiles (one for pub and one for sub)
     + [X] Load publisher profile
     + [X] Load subscriber profile
     + [X] Load topic profiles (topic names and their qos), if they exist
     + [-] Load dynamic type profiles (TO BE REPLACED with those loaded from idl)
       + [X] Use XML first
       + [ ] Use converter to populate instead

   + [ ] Create mapping from dds topic primitive types to fmu value references
   + [ ] Generate modelDescription from mapping
     + [ ] version, guid, CoSimulation
     + [ ] ModelVariables auto-populate
     + [ ] ModelStructure auto-populate
   + [ ] Create publishers/subscribers from mapping
   + [ ] Add GTest for systematic tests of functionality
   + [X] File loader with staging directory (std::filesystem)
   + [X] GUID functionality (replicate CMake target) with stduuid
     - hard-code which files to hash
     - do not hash line with hash in model description
     - model description contains a version tag, which is acquired from API compile def/configure_file (version.txt)
     - hash all idl files in idl folder (resource) *.idl
     - hash fast-dds config file(s) (resource) dds-fmu-profile.xml
     - eval GUID must be possible given model description and mentioned files
   + [X] CMake Target to generate GUID using stduuid functionality
   + [ ] Generate modelDescription.xml
     - given idl files and xml, model description must be generate-able
     - must be possible through bundled library API
   + [-] Zip staging directory
     - [X] zip the staged/binary and generated files
     - [ ] Figure out why permissions are lost
     - the only file not explicitly available before rendering is modelDescription.xml
   + [ ] Make documentation target and bundle it with the fmu

   + [3/5] Repackaging
     1. [X] Command line tool: positional arg: point to folder to be packaged
     2. [ ] Parse idls, xml profile and other config files
        - [ ] Create mock-up parser with placeholders for each step
     3. [X] Produce GUID based on modelDescription template info and config files
        - Allow tweaking e.g. ModelStructure as long as consistency is retained?
     4. [ ] Write modelDescription from XML tree and evaluated GUID
     5. [X] Zip files into fmu

** User configuration insight

   + A mapping from FMU signals to DDS signals is to be made possible
   + Knowledge of both FMU signals and DDS types&topics to be interconnected is assumed
   + The user writes configuration files to generate necessary config files for both FMU and DDS
     + The IDL file parsed by xtypes is used to convert/generate DynamicData types in fast-dds -> i.e. no idl compiler needed
       + Need to confirm that this is possible. It is, with some limitations to annotations.
       + Alternatively, the IDL must be compiled into a dynamic library with type definitions that can be loaded at runtime (fallback)
   + The user writes XML profiles for DDS-related configuration
     + General configuration of participant, etc.
     + Settings for publishers and subscribers, including topic name, data type, qos (esp. durability and reliability)
   + The user or some program writes a mapping between FMU signals and DDS topic members
     + The provided information must be sufficient so that a mapping between primitive types are possible
     + FMU source type may not be the same as DDS destination primitive type
     + Must be possible to construct nested topic member variable names to create function mapping from fmu signal
     + Data types in DDS dictates the most closely related type on the FMI side
     + There are conventions on with =.= and =[]= for referencing non-primitive types
       + It is possible to auto-generate FMU inputs and outputs based on DDS topics and their types

** Research notes
   + Given an IDL-file, convert to xtypes, achieved with eprosima/xtypes header only library
   + [[https://github.com/eProsima/FastDDS-SH/blob/main/src/Conversion.hpp][This converts from xtypes to Dynamic Types]] in Fast DDS -> perhaps useful
   + [[https://github.com/eProsima/xtypes/issues/82#issuecomment-785089279][This issue indicates conversion of xtypes to Dynamic Types]]
     + Investigate if xtypes has been integrated properly, of if this conversion is still needed
     + If not integrated: load IDL file with xtypes library, convert to Dynamic Types
     + The mapping from FMU input/output to DDS publish/subscribe may still need the
       information provided by the xtypes in order to reference these.
   + Specification of subscribers and publishers using Fast-DDS XML profiles
     + Important to retain configurability of the profiles made possible with the XML files

* References

  + [[https://www.spectric.com/post/multicast-within-kubernetes][Multicast within kubernetes]]
  + [[https://k3s.io/][k3s]]
